## **集合概述**

***

### **Java集合概述**

Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 `Collection`接口，主要用于存放单一元素；另一个是 `Map` 接口，主要用于存放键值对。对于`Collection` 接口，下面又有三个主要的子接口：`List`、`Set` 和 `Queue`。

![Java 集合框架概览](D:\Files\java工作\pictures\java集合框架.png)

![image.png](D:\Files\java工作\pictures\java集合底层.png)

**`HashSet`：**底层数据结构是hash表，基于`HashMap`实现。 

**`HashMap`：** JDK1.8 之前：`HashMap` 由数组+链表组成的，数组是 `HashMap` 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。 JDK1.8 以后：在解决哈希冲突时有了较大的变化，**当链表长度大于阈值（默认为 8）**（将链表转换成红黑树前会判断，**如果当前数组的长度小于 64，那么会选择先进行数组扩容**，而不是转换为红黑树)时，将链表转化为红黑树，以减少搜索时间。

**`LinkedHashMap`：**`LinkedHashMap` 继承自 `HashMap`，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，`LinkedHashMap` 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。

**`Hashtable`：**数组+链表组成的，数组是 `Hashtable` 的主体，链表则是主要为了解决哈希冲突而存在的

**`priorityQueue`：** `Object[]` 数组来实现二叉堆

**`ArrayQueue`：** `Object[]` 数组 + 双指针

### **说说 List，Set， Queue， Map 四者的区别？**

- `List`（对付顺序的好帮手）：存储的元素是有序的、可重复的。
- `Set`（注重独一无二的性质)： 存储的元素是无序的、不可重复的。
- `Queue`(实现排队功能的叫号机)：按特定的排队规则来确定先后顺序，存储的元素是有序的、可重复的。
- `Map`(用 key 来搜索的专家)： 使用键值对（key-value）存储，key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。

### **为什么要使用集合？**

当我们需要存储一组类型相同的数据时，数组是最常用且最基本的容器之一。但是，使用数组存储对象存在一些不足之处，因为在实际开发中，存储的数据类型多种多样且数量不确定。这时，Java 集合就派上用场了。与数组相比，Java 集合提供了更灵活、更有效的方法来存储多个数据对象。Java 集合框架中的各种集合类和接口可以存储不同类型和数量的对象，同时还具有多样化的操作方式。相较于数组，Java 集合的优势在于它们的**大小可变**、**支持泛型**、**具有内建算法**等。总的来说，Java 集合提高了数据的存储和处理灵活性，可以更好地适应现代软件开发中多样化的数据需求，并支持高质量的代码编写。



## **List**

***

### **ArrayList 和 Array（数组）的区别？**

`ArrayList` 内部基于动态数组实现，比 `Array`（静态数组） 使用起来更加灵活：

- `ArrayList`会根据实际存储的元素**动态地扩容或缩容**，而 `Array` 被创建之后就不能改变它的长度了。
- `ArrayList` 允许你**使用泛型**来确保类型安全，`Array` 则不可以。
- `ArrayList` 中**只能存储对象**。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。`Array` 可以直接存储基本类型数据，也可以存储对象。
- `ArrayList` 支持插入、删除、遍历等常见操作，并且提供了丰富的 **API 操作方法**，比如 `add()`、`remove()`等。`Array` 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。
- `ArrayList`创建时不需要指定大小，而`Array`创建时必须指定大小。

### **ArrayList 和 Vector 的区别?（了解即可）**

`ArrayList` 是 `List` 的主要实现类，底层使用 `Object[]`存储，**适用于频繁的查找工作，线程不安全** 。

`Vector` 是 `List` 的古老实现类，底层使用`Object[]` 存储，**线程安全**。

### **Vector 和 Stack 的区别?（了解即可）**

- `Vector` 和 `Stack` 两者都是**线程安全**的，都是**使用 `synchronized` 关键字进行同步处理**。
- `Stack` 继承自 `Vector`，是一个后进先出的栈，而 `Vector` 是一个列表。

随着 Java 并发编程的发展，`Vector` 和 `Stack` 已经被淘汰，推荐使用并发集合类（例如 `ConcurrentHashMap`、`CopyOnWriteArrayList` 等）或者手动实现线程安全的方法来提供安全的多线程操作支持

### **ArrayList插入和删除元素的时间复杂度？**

对于插入：

- **头部插入：**由于需要将所有元素都依次向后移动一个位置，因此**时间复杂度是 O(n)**。
- **尾部插入：**当 `ArrayList` 的**容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)**，因为它只需要在数组末尾添加一个元素即可；当容量已达到极限并且**需要扩容时，则需要执行一次 O(n) 的操作将原数组复制到新的更大的数组中，然后再执行 O(1) 的操作添加元素。**
- **指定位置插入：**需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。这个过程需要移动平均 n/2 个元素，因此**时间复杂度为 O(n)**。

对于删除：

- **头部删除：**由于需要将所有元素依次向前移动一个位置，因此**时间复杂度是 O(n)**。
- **尾部删除：**当删除的元素位于列表末尾时，**时间复杂度为 O(1)**。
- **指定位置删除：**需要将目标元素之后的所有元素向前移动一个位置以填补被删除的空白位置，因此需要移动平均 n/2 个元素，**时间复杂度为 O(n)**。

### **LinkedList 插入和删除元素的时间复杂度？**

[[LinkedList 源码分析 | JavaGuide(Java面试 + 学习指南)](https://javaguide.cn/java/collection/linkedlist-source-code.html)]

- **头部插入/删除：**只需要修改头结点的指针即可完成插入/删除操作，因此**时间复杂度为 O(1)**。

- **尾部插入/删除：**只需要修改尾结点的指针即可完成插入/删除操作，因此**时间复杂度为 O(1)**。

- **指定位置插入/删除：**需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间**复杂度为 O(n)**。

### **LinkedList 为什么不能实现 RandomAccess 接口？**

`RandomAccess` 是**一个标记接口**，用来表明实现该接口的类支持随机访问（即可以通过索引快速访问元素）。由于 **`LinkedList` 底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现 `RandomAccess` 接口。**

> 查看源码我们发现实际上 `RandomAccess` 接口中什么都没有定义。所以，在我看来 `RandomAccess` 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。在 `binarySearch（)` 方法中，它要判断传入的 list 是否 `RandomAccess` 的实例，如果是，调用`indexedBinarySearch()`方法，如果不是，那么调用`iteratorBinarySearch()`方法。

### **ArrayList 与 LinkedList 区别**

- **是否保证线程安全：** `ArrayList` 和 `LinkedList` 都是不同步的，也就是**不保证线程安全**；

- **底层数据结构：** `ArrayList` 底层使用的是 **`Object` 数组**；`LinkedList` 底层使用的是 **双向链表** 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）

- **插入和删除是否受元素位置的影响：**

  - `ArrayList` 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行`add(E e)`方法的时候， `ArrayList` 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（`add(int index, E element)`），时间复杂度就为 O(n)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。

  - `LinkedList` 采用链表存储，所以在头尾插入或者删除元素不受元素位置的影响（`add(E e)`、`addFirst(E e)`、`addLast(E e)`、`removeFirst()`、 `removeLast()`），时间复杂度为 O(1)，如果是要在指定位置 `i` 插入和删除元素的话（`add(int index, E element)`，`remove(Object o)`,`remove(int index)`）， 时间复杂度为 O(n) ，因为需要先移动到指定位置再插入和删除。

- **是否支持快速随机访问：** `LinkedList` 不支持高效的随机元素访问，而 `ArrayList`（实现了 `RandomAccess` 接口） 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于`get(int index)`方法)。

- **内存空间占用：** `ArrayList` 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。



